enum Permission {
  ADMIN
  USER
}

type User {
  id: ID! @id
  email: String! @unique
  name: String!
  password: String!
  permissions: [Permission!]!
    @scalarList(strategy: RELATION)
    @default(value: USER)
  participatingBrewingProcesses: [BrewingProcess!]!
    @relation(name: "BrewingProcessToUser", onDelete: SET_NULL, link: TABLE)
}

################### BrewingProcess ###################

type BrewingProcess {
  id: ID! @id
  name: String!
  description: String!
  activeSteps: [BrewingStep!]! @scalarList(strategy: RELATION)
  brewingProcessDetails: BrewingProcessDetails!
    @relation(name: "BrewingProcessDetails", link: INLINE, onDelete: CASCADE)

  # graphs linked to this brewing process
  graphs: [Graph!]! @relation(name: "BrewingProcessToGraph", onDelete: CASCADE)
  # participating users
  users: [User!]! @relation(name: "BrewingProcessToUser", onDelete: SET_NULL)
  # corresponding media streams
  mediaStreams: [MediaStream!]!
    @relation(name: "BrewingProcessToMediaStream", onDelete: CASCADE)

  # some timestamps
  start: DateTime # null -> not yet started
  end: DateTime # null -> not ended yet
  heatingUpStart: DateTime # null -> not yet started
  mashIn: DateTime # null -> not yet started
  boilingStart: DateTime # null -> not yet started
  fermentationStart: DateTime # null -> not yet started
}

type BrewingProcessDetails {
  id: ID! @id

  # predetermined recipe values
  malts: [Ingredient!]! @relation(name: "Malts", onDelete: CASCADE)
  yeast: Ingredient! @relation(name: "Yeast", onDelete: CASCADE)
  mashWaterLiter: Float!
  spargingWaterLiter: Float!
  yieldsLiter: Float!
  carbonizationGramPerLiter: Float!
  mashInTemperature: Float!
  mashSteps: [Step!]! @relation(name: "MashSteps", onDelete: CASCADE)
  spargingTemperature: Float!
  boilingMinutes: Int!
  boilHopAdditions: [boilHopAddition!]!
    @relation(name: "BoilHopAddition", onDelete: CASCADE)
  dryHopping: dryHopAddition
    @relation(name: "DryHopAddition", onDelete: CASCADE) # can be set to null for no dry hopping
  fermentationSteps: [Step!]!
    @relation(name: "FermentationSteps", onDelete: CASCADE)

  # to be added during/after brewing
  originalExtractPlato: Float
  pitchingTemperature: Float
  alcoholPercent: Float
  conditioningDays: Int # days until botteling
}

type Ingredient {
  id: ID! @id
  type: IngredientType!
  name: String!
  amountGram: Float!
  details: String
}

type Step {
  id: ID! @id
  durationMinutes: Int!
  temperature: Float!
  details: String
  # filled out during process
  start: DateTime
  end: DateTime
}

type boilHopAddition {
  id: ID! @id
  hop: Ingredient! @relation(name: "BoilHop", onDelete: CASCADE)
  minutesAfterBoilStart: Int!
}

type dryHopAddition {
  id: ID! @id
  hop: Ingredient! @relation(name: "DryHop", onDelete: CASCADE)
  addedOn: DateTime # to be edited when actually added
}

enum IngredientType {
  MALT
  HOP
  YEAST
}

enum BrewingStep {
  MALT_CRUSHING
  HEATING_UP
  MASH_IN
  MASHING
  HEATING_SPARGE
  LAUTERING
  SPARGING
  BOILING
  CHILLING
  FERMENTING
  CONDITIONING
  BOTTLED
}

################### Graph ###################

type Graph {
  id: ID! @id
  name: String!
  sensorName: String! # mqtt topic
  active: Boolean! # only one active graph per sensor, while there can be multiple brewing processes active..
  updateFrequency: Int! # in seconds
  brewingProcess: BrewingProcess!
    @relation(name: "BrewingProcessToGraph", onDelete: SET_NULL) # link to brewing process
  graphData: [GraphData!]!
    @relation(name: "GraphToGraphData", onDelete: CASCADE) # its "content"
}

type GraphData {
  id: ID! @id
  time: DateTime!
  value: String!
  graph: Graph! @relation(name: "GraphToGraphData", onDelete: SET_NULL)
}

################### Media ###################

# MediaStreams currently support near real-time only. It's more of a
# documentation of the recent progress than it is a "live stream" of camera images.
# While technically possible, live streaming with multiple cameras produces huge
# data that has to be stored somewhere -> expensive
# So, a media stream holds a collection of media (links). Which could of course be videos..
type MediaStream {
  id: ID! @id
  mediaFilesName: String! # names of media files this stream should "collect" (TODO description to come)
  brewingSteps: [BrewingStep!]! @scalarList(strategy: RELATION) # relating to "position" in brewing process ("where to display")(TODO description to come)
  overwrite: Boolean! # only latest MediaFile is stored
  active: Boolean! # if false, media stream does not record any media anymore
  updateFrequency: Int! # in seconds
  brewingProcess: BrewingProcess!
    @relation(name: "BrewingProcessToMediaStream", onDelete: SET_NULL) # link to brewing process
  mediaFiles: [MediaFile!]!
    @relation(name: "MediaStreamToMediaFile", onDelete: CASCADE) # its "content"
}

type MediaFile {
  id: ID! @id
  time: DateTime!
  publicIdentifier: String!
  mediaStream: MediaStream!
    @relation(name: "MediaStreamToMediaFile", onDelete: SET_NULL)
}
